import requests
import logging
import time
import tkinter as tk
from tkinter import messagebox, simpledialog

class VulnerabilityScannerGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("Vulnerability Scanner")
        self.root.geometry("600x600")
        self.root.configure(bg="#2E2E2E")  # Dark background

        self.target_url = ""
        self.vulnerabilities = []
        self.logger = self.setup_logger()
        self.auth = None
        self.headers = {}

        # GUI Widgets
        self.create_widgets()

    def setup_logger(self):
        logger = logging.getLogger("VulnerabilityScanner")
        logger.setLevel(logging.DEBUG)
        console_handler = logging.StreamHandler()
        console_handler.setLevel(logging.DEBUG)
        file_handler = logging.FileHandler("scan_report.log")
        file_handler.setLevel(logging.DEBUG)
        formatter = logging.Formatter("%(asctime)s - %(levelname)s - %(message)s")
        console_handler.setFormatter(formatter)
        file_handler.setFormatter(formatter)
        logger.addHandler(console_handler)
        logger.addHandler(file_handler)
        return logger

    def create_widgets(self):
        label_style = {"bg": "#2E2E2E", "fg": "#FFFFFF", "font": ("Arial", 12)}
        entry_style = {"bg": "#3C3F41", "fg": "#FFFFFF", "insertbackground": "#FFFFFF", "font": ("Arial", 12)}
        button_style = {"bg": "#4CAF50", "fg": "#FFFFFF", "activebackground": "#45A049", "font": ("Arial", 12)}

        # Target URL Entry
        self.url_label = tk.Label(self.root, text="Target URL:", **label_style)
        self.url_label.pack(pady=10)
        self.url_entry = tk.Entry(self.root, width=50, **entry_style)
        self.url_entry.pack(pady=5)

        # Scan Type Selection
        self.scan_type_label = tk.Label(self.root, text="Select Scan Type:", **label_style)
        self.scan_type_label.pack(pady=10)
        self.scan_type_var = tk.StringVar(value="xss")
        self.scan_type_menu = tk.OptionMenu(self.root, self.scan_type_var, "xss", "sql", "directory", "custom")
        self.scan_type_menu.configure(bg="#3C3F41", fg="#FFFFFF", activebackground="#45A049", font=("Arial", 12))
        self.scan_type_menu.pack(pady=5)

        # Start Scan Button
        self.scan_button = tk.Button(self.root, text="Start Scan", command=self.start_scan, **button_style)
        self.scan_button.pack(pady=20)

        # Output Log Display
        self.output_text = tk.Text(self.root, height=10, width=70, wrap=tk.WORD, bg="#1E1E1E", fg="#00FF00", font=("Consolas", 10))
        self.output_text.pack(pady=10)
        self.output_text.config(state=tk.DISABLED)

        # Clear Button
        self.clear_button = tk.Button(self.root, text="Clear Output", command=self.clear_output, bg="#D32F2F", fg="#FFFFFF", activebackground="#B71C1C", font=("Arial", 12))
        self.clear_button.pack(pady=5)

    def log_to_gui(self, message):
        self.output_text.config(state=tk.NORMAL)
        self.output_text.insert(tk.END, message + "\n")
        self.output_text.config(state=tk.DISABLED)

    def prompt_for_target_url(self):
        self.target_url = self.url_entry.get().strip()
        if not self.target_url:
            messagebox.showwarning("Input Error", "Please enter a valid URL!")
            return False
        return True

    def prompt_for_authentication(self):
        use_auth = messagebox.askyesno("Authentication", "Do you need authentication for this site?")
        if use_auth:
            username = simpledialog.askstring("Username", "Enter your username:")
            password = simpledialog.askstring("Password", "Enter your password:", show="*")
            self.auth = (username, password)
            self.log_to_gui("Basic authentication set.")
        else:
            self.auth = None
            self.log_to_gui("No authentication required.")

    def prompt_for_custom_payload(self):
        custom_payload = simpledialog.askstring("Custom Payload", "Enter your custom payload (or leave empty to use default):")
        return custom_payload if custom_payload else None

    def measure_response_time(self, url, method="GET", data=None):
        start_time = time.time()
        try:
            if method == "GET":
                response = requests.get(url, auth=self.auth, headers=self.headers)
            elif method == "POST":
                response = requests.post(url, data=data, auth=self.auth, headers=self.headers)
            response_time = time.time() - start_time
            self.log_to_gui(f"Response time: {response_time:.4f} seconds")
            return response, response_time
        except requests.RequestException as e:
            self.log_to_gui(f"Request failed: {e}")
            return None, None

    def start_scan(self):
        if not self.prompt_for_target_url():
            return

        self.prompt_for_authentication()

        scan_type = self.scan_type_var.get()
        self.log_to_gui(f"Starting {scan_type.upper()} scan on {self.target_url}...")

        if scan_type == "xss":
            self.scan_xss()
        elif scan_type == "sql":
            self.scan_sql_injection()
        elif scan_type == "directory":
            self.scan_directory_traversal()
        elif scan_type == "custom":
            self.scan_custom_payload()

        self.show_vulnerabilities()

    def scan_xss(self):
        payload = "<script>alert('XSS')</script>"
        self.log_to_gui(f"Testing for XSS using payload: {payload}")
        response, response_time = self.measure_response_time(self.target_url, "POST", {"input": payload})
        if response and payload in response.text:
            self.vulnerabilities.append("XSS vulnerability found!")
            self.log_to_gui("XSS vulnerability found!")
        else:
            self.log_to_gui("No XSS vulnerability found.")

    def scan_sql_injection(self):
        payload = "' OR '1'='1"
        self.log_to_gui(f"Testing for SQL injection using payload: {payload}")
        response, response_time = self.measure_response_time(self.target_url + "?id=" + payload)
        if response and "error" in response.text:
            self.vulnerabilities.append("SQL injection vulnerability found!")
            self.log_to_gui("SQL injection vulnerability found!")
        else:
            self.log_to_gui("No SQL injection vulnerability found.")

    def scan_directory_traversal(self):
        payload = "../../../../etc/passwd"
        self.log_to_gui(f"Testing for Directory traversal using payload: {payload}")
        response, response_time = self.measure_response_time(self.target_url + payload)
        if response and "root:x" in response.text:
            self.vulnerabilities.append("Directory traversal vulnerability found!")
            self.log_to_gui("Directory traversal vulnerability found!")
        else:
            self.log_to_gui("No directory traversal vulnerability found.")

    def scan_custom_payload(self):
        custom_payload = self.prompt_for_custom_payload()
        if not custom_payload:
            self.log_to_gui("No custom payload provided. Skipping custom scan.")
            return
        self.log_to_gui(f"Testing for vulnerability using custom payload: {custom_payload}")
        response, response_time = self.measure_response_time(self.target_url, "POST", {"input": custom_payload})
        if response and custom_payload in response.text:
            self.vulnerabilities.append("Custom vulnerability found!")
            self.log_to_gui("Custom vulnerability found!")
        else:
            self.log_to_gui("No custom vulnerability found.")

    def show_vulnerabilities(self):
        if self.vulnerabilities:
            self.log_to_gui("Vulnerabilities found:")
            for vuln in self.vulnerabilities:
                self.log_to_gui(f"- {vuln}")
        else:
            self.log_to_gui("No vulnerabilities found.")

    def clear_output(self):
        self.output_text.config(state=tk.NORMAL)
        self.output_text.delete(1.0, tk.END)
        self.output_text.config(state=tk.DISABLED)


# Main application
if __name__ == "__main__":
    root = tk.Tk()
    app = VulnerabilityScannerGUI(root)
    root.mainloop()
